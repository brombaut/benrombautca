<h2 id="first---a-note-on-big-o">First - a note on Big O</h2>
<p>Big O notation is special notation that tells you how fast an
algorithm is. For example, suppose you have a list of size <em>n</em>.
Simple search needs to check each element, so it will take n operations.
The run time in Big O notation is O(<em>n</em>). It’s important to note
that Big O doesn’t tell you the speed in seconds, but rather lets you
compare the number of operations. It tells you have fast the algorithm
grows.</p>
<h3 id="big-o-establishes-a-worst-case-run-time.">Big O establishes a
worst-case run time.</h3>
<p>Suppose you’re using simple search to look for a person in the phone
book. You know that simple search takes O(<em>n</em>) time to run, which
means in the worst case, you’ll have to look through every single entry
in your phone book. In this case, you’re looking for Adit. This guy is
the first entry in your phone book. So you didn’t have to look at every
entry - you found it on the first try. Did this algorithm take
O(<em>n</em>) time? Or did it take O(1) (i.e., constant) time because
you found the person on the first try?</p>
<p>Simple search still takes O(<em>n</em>) time. In this case, you found
what you were looking for instantly. That’s the best-case scenario. But
Big O notation is about the <em>worst-case</em> scenario. So you can say
that, in the <em>worst case</em>, you’ll have to look at every entry in
the phone book once. That’s O(<em>n</em>) time. It’s a reassurance - you
know that the simple search will never be slower than O(<em>n</em>)
time.</p>
<blockquote>
<p>Note: Along with worst-case run time, it’s also important to look at
the average-case run time. More on that later…</p>
</blockquote>
<h3 id="some-common-big-o-run-times">Some common Big O run times:</h3>
<ul>
<li>O(log <em>n</em>), also known as <em>log time</em>. Example: Binary
search.</li>
<li>O(<em>n</em>), also known as <em>linear time</em>. Example: Simple
search.</li>
<li>O(<em>n</em> * log <em>n</em>). Example: A fast sorting algorithm,
like quicksort.</li>
<li>O(<em>n<sup>2</sup></em>). Example: A slow sorting algorithm, like
selection sort.</li>
<li>O(<em>n!</em>). Example: A really slow algorithm, like the traveling
salesman.</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/brombaut/articles-authored/main/assets/images/search_and_sort_algorithms/big_o.png" /></p>
<h2 id="searching-algorithms">Searching Algorithms</h2>
<h3 id="simple-search">Simple Search</h3>
<p>Just start at the beginning of the list and loop over all elements
until either the item is found, or the end of the list is reached (in
which case, the item is not in the list).</p>
<p>Time complexity: O(<em>n</em>)</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_search(my_list, item):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  i <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Start searching from the start of the list</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(my_list):  <span class="co"># While there are still elements to check in the list...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    guess <span class="op">=</span> my_list[i]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> guess <span class="op">==</span> item:  <span class="co"># Found the item</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> i</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="va">None</span></span></code></pre></div>
<h3 id="binary-seach">Binary Seach</h3>
<p>The idea of binary search is that, with a sorted list and an item to
find, you guess the middle item and eliminate half of all possibilities
with each guess.</p>
<blockquote>
<p>Note: Binary search only works when your list is in sorted order.</p>
</blockquote>
<p>Time complexity: O(log <em>n</em>)</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search(my_list, item):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># low and high keep track of which</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># part of the list you&#39;ll search in.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  low <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  high <span class="op">=</span> <span class="bu">len</span>(my_list) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> low <span class="op">&lt;=</span> high:  <span class="co"># While you haven&#39;t narrows it down to one element...</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (low <span class="op">+</span> high) <span class="op">/</span> <span class="dv">2</span>  <span class="co"># ...check the middle element</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    guess <span class="op">=</span> my_list[mid]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> guess <span class="op">==</span> item:  <span class="co"># Found the item</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> mid</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> guess <span class="op">&gt;</span> item:  <span class="co"># The guess was too high</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      high <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:  <span class="co"># The guess was too low</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      low <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="va">None</span>  <span class="co"># The item doesn&#39;t exist</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>my_list <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>]</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(binary_search(my_list, <span class="dv">3</span>))  <span class="co"># =&gt; 1</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(binary_search(my_list, <span class="op">-</span><span class="dv">1</span>)) <span class="co"># =&gt; None</span></span></code></pre></div>
<h3 id="breadth-first-search">Breadth-First Search</h3>
<blockquote>
<h4 id="first-a-note-on-graphs">First: A note on <em>Graphs</em></h4>
<p>A graph models a set of connections. Graphs are made up of nodes and
edges. A node can be directly connected to many other nodes. Those nodes
are called its neighbors. Graphs are a way to model how different things
are connected to one another.</p>
</blockquote>
<p>Breadth-first search is a search algorithm that runs on graphs. It
can help to answer two types of questions: - 1: Is there a path from
node A to node B? - 2: What is the shortest path from node A to node
B?</p>
<p>The idea behind breadth-first search is that you maintain a queue of
nodes you need to check (note that a <code>queue</code> follows the
first in, first out rule (FIFO), as opposed to a <code>stack</code>,
which follows a first in, last out rule (FILO)). You first visit all of
your immediate neighbours (i.e., all the nodes you are directly
connected with get added to the queue) and check to see if they are the
node you are looking for.</p>
<p>As you visit a node, you add all of its direct neighbours to your
search queue (i.e., enqueue), taking care not to add any nodes to the
queue that you have already visited. You then keep dequeueing nodes from
your search queue until you either find the node you are looking for, or
your queue becomes empty, in which case the node you are looking for is
not present in the graph.</p>
<p>In summary, you search the nodes that are closest to you first, and
keep expanding your search away from you until you find the node you
want or you have searched the whole graph. Bread-first search guarentees
that you will find the node in the graph if it is present, as well as
that you will find the shortest path to that node.</p>
<p><strong>Time complexity</strong>: If you search your entire graph,
that means you’ll follow each edge. So the running time is at least
O(number of edges). You also keep a queue of every node to search.
Adding a node to the queue takes constant time: O(1). Doing this for
every node will take O(number of people) total. Therefore, breadth-first
search takes O(number of people + number of edges), and is more commonly
written as O(V+E) (V for vertices, E for edges)</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {}</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;you&quot;</span>] <span class="op">=</span> [<span class="st">&quot;alice&quot;</span>, <span class="st">&quot;bob&quot;</span>, <span class="st">&quot;claire&quot;</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;bob&quot;</span>] <span class="op">=</span> [<span class="st">&quot;arthur&quot;</span>, <span class="st">&quot;peggy&quot;</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;alice&quot;</span>] <span class="op">=</span> [<span class="st">&quot;peggy&quot;</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;claire&quot;</span>] <span class="op">=</span> [<span class="st">&quot;tom&quot;</span>, <span class="st">&quot;jonny&quot;</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;arthur&quot;</span>] <span class="op">=</span> []</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;peggy&quot;</span>] <span class="op">=</span> []</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;tom&quot;</span>] <span class="op">=</span> []</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;jonny&quot;</span>] <span class="op">=</span> []</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search(name):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  search_queue <span class="op">=</span> deque()</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  search_queue <span class="op">+=</span> graph[name]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  searched <span class="op">=</span> []  <span class="co"># Who you&#39;ve already searched</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> search_queue:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    person <span class="op">=</span> search_queue.popleft()</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> person <span class="kw">in</span> searched: <span class="co"># Only search this person if you haven&#39;t already searched them</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> person_is_who_we_are_looking_for(person):</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        search_queue <span class="op">+=</span> graph[person]</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        searched.append(person)  <span class="co"># Mark this person as searched</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>search(<span class="st">&quot;you&quot;</span>)  <span class="co"># Will starting search from the &quot;you&quot; node and return true if we find the person we are looking for (implemented in person_is_who_we_are_looking_for, not included)</span></span></code></pre></div>
<h3 id="dijkstras-algorithm">Dijkstra’s Algorithm</h3>
<p>Lets you answer “What is the shortest path to X?” for weighted graphs
(i.e., graphs with edges that have a weight or value assigned to
them).</p>
<p>There are four steps to Dijkstra’s algorith: - 1: Find the “cheapest”
node. That is the node you can get to in the least amount of time. - 2:
Check whether there’s a cheaper path to the neighbors of this node. If
so, opdate the costs of these neighbors. - 3: Repeat until you’ve done
this for every node in the graph. - 4: Calculate the final path.</p>
<p>A full explanation on each of these steps will be a bit long-winded,
so follow the code implementation below, and use Google is things aren’t
clear. Still, there are a couple points to note: - You can’t use
Dijkstra’s algorithm if you have negative weight edges (see <a
href="https://www.geeksforgeeks.org/why-does-dijkstras-algorithm-fail-on-negative-weights/">this
explanation</a>). If you have negative weights, use the <a
href="https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/">Bellman–Ford
Algorithm</a>. - Dijkstra’s algorithm only works on graphs with no
cycles, or on graphs with a positive weight cycle.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">First describe the graph</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {}</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;start&quot;</span>] <span class="op">=</span> {} <span class="co"># Start node</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;start&quot;</span>][<span class="st">&quot;a&quot;</span>] <span class="op">=</span> <span class="dv">6</span> <span class="co"># Start node is connected to A node, with edge weight of 6</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;start&quot;</span>][<span class="st">&quot;b&quot;</span>] <span class="op">=</span> <span class="dv">2</span> <span class="co"># Start node is connected to B node, with edge weight of 2</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;a&quot;</span>] <span class="op">=</span> {} <span class="co"># A node </span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;a&quot;</span>][<span class="st">&quot;fin&quot;</span>] <span class="op">=</span> <span class="dv">1</span> <span class="co"># A node is connected to Finish node, with edge weight of 1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;b&quot;</span>] <span class="op">=</span> {} <span class="co"># B node</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;b&quot;</span>][<span class="st">&quot;a&quot;</span>] <span class="op">=</span> <span class="dv">3</span> <span class="co"># B node is connected to A node, with edge weight of 3</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;b&quot;</span>][<span class="st">&quot;fin&quot;</span>] <span class="op">=</span> <span class="dv">5</span> <span class="co"># B node is connected to Finish node, with edge weight of 5</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>graph[<span class="st">&quot;fin&quot;</span>] <span class="op">=</span> {}  <span class="co"># Finish node, doesn&#39;t have any neightbors</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co">Then you need a has table to store the costs for each node.</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="co">The cost of a node is how long it takes to get to that node from the start.</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="co">You know it takes 2 minutes from Start to node B. </span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="co">You know it takes 6 minutes to get to node A (although you may find a path that takes less time).</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="co">You don&#39;t know how long it takes to get to the finish.</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="co">If you don&#39;t know the cost yet, you put down infinity.</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>infinity <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;inf&quot;</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>costs <span class="op">=</span> {}</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>costs[<span class="st">&quot;a&quot;</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>costs[<span class="st">&quot;b&quot;</span>] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>costs[<span class="st">&quot;fin&quot;</span>] <span class="op">=</span> infinity</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="co">You also need another has table for the parents</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>parents <span class="op">=</span> {}</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>parents[<span class="st">&quot;a&quot;</span>] <span class="op">=</span> <span class="st">&quot;start&quot;</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>parents[<span class="st">&quot;b&quot;</span>] <span class="op">=</span> <span class="st">&quot;start&quot;</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>parents[<span class="st">&quot;fin&quot;</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="co">Finally, you need an array to keep track of all nodes you&#39;ve already processed, because you don&#39;t need to process a node more than once.</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>processed <span class="op">=</span> []</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a><span class="co">Dijkstra&#39;s Algorithm</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>node <span class="op">=</span> find_lowest_cost_node(costs) <span class="co"># Find the lowest-cost node that you haven&#39;t processed yet.</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> node <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>: <span class="co"># If you&#39;ve processed all the nodes, this while loop is done.</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>  cost <span class="op">=</span> costs[node]</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>  neighbors <span class="op">=</span> graph[node]</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> n <span class="kw">in</span> neighbors.keys(): <span class="co"># Go through all the neighbors of this node.</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    new_cost <span class="op">=</span> cost <span class="op">+</span> neighbors[n]</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> costs[n] <span class="op">&gt;</span> new_cost: <span class="co"># If it&#39;s cheaper to get to this neighbor by going through this node...</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>      costs[n] <span class="op">=</span> new_cost <span class="co"># ...update the cost for this node.</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>      parents[n] <span class="op">=</span> node <span class="co"># This node becomes the new parent for this neighbor.</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>  processed.append(node) <span class="co"># Mark this node as processed.</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>  node <span class="op">=</span> find_lowest_cost_node(costs) <span class="co"># Find the next node to process, and loop.</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_lowest_cost_node(costs):</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>  lowest_cost <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;inf&quot;</span>)</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>  lowest_cost_node <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> node <span class="kw">in</span> costs: <span class="co"># Go through each node</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> costs[node]</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cost <span class="op">&lt;</span> lowest_cost <span class="kw">and</span> node <span class="kw">not</span> <span class="kw">in</span> processed: <span class="co"># If it&#39;s the lowest cost so far and hasn&#39;t been processed yet...</span></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>      lowest_cost <span class="op">=</span> cost <span class="co"># ...set it as the new lowest-cost node</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>      lowest_cost_node <span class="op">=</span> node</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> lowest_cost_node</span></code></pre></div>
<h2 id="sorting-algorithms">Sorting Algorithms</h2>
<h3 id="selection-sort">Selection Sort</h3>
<p>The idea of binary search is that you loop over the list, find the
smallest element (assuming you are sorting in ascending order), remove
it from the list while adding it to the end of a new (initially empty)
list, and then loop back over the original list, again finding the
smallest element (remember that the first smallest element has been
removed), and repeat this process until you have a sorted list.</p>
<p>Time complexity: O(<em>n<sup>2</sup></em>)</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_smallest(arr):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  smallest_index <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Stores the index of the smallest value</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  smallest <span class="op">=</span> arr[smallest_index]  <span class="co"># Stores the smallest value</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">1</span>, <span class="bu">len</span>(arr)):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arr[i] <span class="op">&lt;</span> smallest:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>      smallest <span class="op">=</span> arr[i]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      smallest_index <span class="op">=</span> i</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> smallest_index</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> selection_sort(arr):  <span class="co"># Sorts an array</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  new_arr <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(arr)):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    smallest <span class="op">=</span> find_smallest(arr)  <span class="co"># Finds the smallest element in the array...</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    new_arr.append(arr.pop(smallest))  <span class="co"># ...and adds it to the new array</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> new_arr</span></code></pre></div>
<h3 id="quick-sort">Quick Sort</h3>
<p>What’s the simplest array that a sorting algorithm can handle? Well,
some arrays don’t need to be sorted at all. Empty arrays and arrays with
only 1 element are already sorted, so if we encounter these, we don’t
have to do anything because there’s nothing to sort (base case).</p>
<p>An array with two elements is pretty easy to sort too. If the first
element is larger than the second, just swap them.</p>
<p>If there are 3 elements, we can take a “divide and conquer” approach.
First, pick an element from the array. This element is called the
<i>pivot</i>. Now find the elements smaller than the pivot and the
elements larger than the pivot. This is called <i>partitioning</i>. Now
you have:</p>
<ul>
<li>A sub-array of all the numbers less than the pivot</li>
<li>The pivot</li>
<li>A sub-array of all the numbers greater than the pivot. The two
sub-arrays aren’t sorted. They’re just partitioned. But if they were
sorted, then you can just combine the whole thing like this -
<code>left array + pivot + right array</code> - and you get a sorted
array.</li>
</ul>
<p>How do you sort the sub-arrays? Well, the quicksort base case already
knows how to sort arrays of 0, 1 (base cases) and 2 (base case + 1
pivot) elements. So if you call quicksort on the two sub-arrays and then
combine the results, you get a sorted array!</p>
<blockquote>
<p>No matter what pivot you pick, you can call quicksort recursively on
the two sub-arrays.</p>
</blockquote>
<p>Time complexity: Average: O(<em>n</em> * log <em>n</em>), Worst Case:
O(<em>n<sup>2</sup></em>)</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quicksort(arr):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;</span> <span class="dv">2</span>:  <span class="co"># Base case: arrays with 0 or 1 elements are already &quot;sorted&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> arr</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  pivot <span class="op">=</span> arr[<span class="dv">0</span>]  <span class="co"># Recursive case</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  less <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> arr[<span class="dv">1</span>:] <span class="cf">if</span> i <span class="op">&lt;=</span> pivot]  <span class="co"># Sub-array of all the elements less than the pivot</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  greater <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> arr[<span class="dv">1</span>:] <span class="cf">if</span> i <span class="op">&gt;</span> pivot]  <span class="co"># Sub-array of all the elements greater than the pivot</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> quicksort(less) <span class="op">+</span> pivot <span class="op">+</span> quicksort(greater)</span></code></pre></div>
<h2 id="greedy-algorithms">Greedy Algorithms</h2>
<p>A greedy algorithm is simple: at each step, pick the optimal move. In
technical terms <em>at each step you pick the locally optimal solution,
and in the end you’re left with the globally optimal solution</em>. It
is important to note that greedy algorithms don’t always work. However,
sometimes, perfect is the enemy of good. Sometimes all you need is an
algorithm that solves the problem pretty well. And that’s where greedy
algorithms shine, because ther’re siple to write and usually get pretty
close.</p>
<h3 id="e.g.-the-set-covering-problem">E.g., The set-covering
problem</h3>
<p>Suppose you’re starting a radio show. You want to reach listeners in
all 50 states. You have to decide what stations to play on to each all
those listeners. It costs money to be on each station, so you’re trying
to minimize the number of stations you plat on.</p>
<p>You have a list of stations. Each station covers a region, and
there’s overlap.</p>
<p>How do you figure out the smallest set of stations you can play on to
cover all 50 states? Sounds easy? Turns out it’s extremely hard. Here’s
how to do it:</p>
<ol type="1">
<li>List every possible subset of stations. This is called the <em>power
set</em>. There are 2<sup>n</sup> possible subsets.</li>
<li>From these, pick the set with the smallest number of stations that
covers all 50 states.</li>
</ol>
<p>The problem is, it takes a long time to calculate every possible
subset of stations. It takes O(2<sup>n</sup>) time, because there are
2<sup>n</sup> subsets. It’s possible to do if you have a small set of 5
to 10 stations, but let’s say you are able to calculate 10 subsets per
second, then for 100 stations, it will take 4x10<sup>21</sup> years.
There’s no algorithm that solves it fast enough. What can you do?</p>
<h4 id="approximation-algorithms">Approximation algorithms</h4>
<p>You can use a greedy algorithm. Here’s one that comes pretty
close:</p>
<ol type="1">
<li>Pick the station that covers the most states that haven’t been
covered yet. It’s ok if the station covers some states that have been
covered already.</li>
<li>Repeat until all states are covered.</li>
</ol>
<p>This is called an approximation algorithm. When calculating the exact
solution will take too much time, an approximation algorithm will work.
Approximation algorithms are judged by</p>
<ul>
<li>How fast they are</li>
<li>How close they are to the optimal solution</li>
</ul>
<p>Greedy algorithms are a good choice because not only are they simple
to come up with, but that simplicity means they usually run fast too. In
this case, the greedy algorithm runs in O(n<sup>2</sup>) time, where n
is the number of radio stations.</p>
<p>Here us a code example</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>states_needed <span class="op">=</span> <span class="bu">set</span>([<span class="st">&quot;mt&quot;</span>, <span class="st">&quot;wa&quot;</span>, <span class="st">&quot;or&quot;</span>, <span class="st">&quot;id&quot;</span>, <span class="st">&quot;nv&quot;</span>, <span class="st">&quot;ut&quot;</span>, <span class="st">&quot;ca&quot;</span>, <span class="st">&quot;az&quot;</span>])</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>stations <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>stations[<span class="st">&quot;kone&quot;</span>] <span class="op">=</span> <span class="bu">set</span>([<span class="st">&quot;id&quot;</span>, <span class="st">&quot;nv&quot;</span>, <span class="st">&quot;ut&quot;</span>])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>stations[<span class="st">&quot;ktwo&quot;</span>] <span class="op">=</span> <span class="bu">set</span>([<span class="st">&quot;wa&quot;</span>, <span class="st">&quot;id&quot;</span>, <span class="st">&quot;mt&quot;</span>])</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>stations[<span class="st">&quot;kthree&quot;</span>] <span class="op">=</span> <span class="bu">set</span>([<span class="st">&quot;or&quot;</span>, <span class="st">&quot;nv&quot;</span>, <span class="st">&quot;ca&quot;</span>])</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>stations[<span class="st">&quot;kfour&quot;</span>] <span class="op">=</span> <span class="bu">set</span>([<span class="st">&quot;nv&quot;</span>, <span class="st">&quot;ut&quot;</span>])</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>stations[<span class="st">&quot;kfive&quot;</span>] <span class="op">=</span> <span class="bu">set</span>([<span class="st">&quot;ca&quot;</span>, <span class="st">&quot;az&quot;</span>])</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>final_stations <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>best_station <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>states_covered <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> states_needed:</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  best_station <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  states_covered <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> station, states_for_station <span class="kw">in</span> stations.items():</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    covered <span class="op">=</span> states_needed <span class="op">&amp;</span> states_for_station  <span class="co"># intersection</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(covered) <span class="op">&gt;</span> <span class="bu">len</span>(states_covered):</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>      best_station <span class="op">=</span> station</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>      states_covered <span class="op">=</span> covered</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    states_needed <span class="op">-=</span> states_covered</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    final_stations.add(best_station)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_stations)</span></code></pre></div>
<h2 id="a-quick-note-on-np-completeness">A quick note on
NP-completeness</h2>
<p>Some problems are famously hard to solve. The traveling salesperson
and the set-covering problem are two examples. A lot of smart people
think that it’s not possible to write an algorithm that will solve these
problems quickly. ### How do you tell if a problem is NP-complete?</p>
<p>Jonah is picking players for his fantasy football team. He has a list
of abilities he wants: good quarterback, good running back, good in
rain, good under pressure, and so on. He has a list of players, where
each player fulfills some abilities. Jonah needs a team that fulfills
all his abilities, and the team size is limited.</p>
<p>This is actually a set-covering problem. Jonah can use the same
approximation algorithm we just did to create his team:</p>
<ol type="1">
<li>Find the player who fulfills the most abilities that haven’t been
fulfilled yet.</li>
<li>Repeat until the team fulfills all abilities (or you run out of
space on the team).</li>
</ol>
<p>NP-complete problems show up everywhere. It’s nice to know if the
problem you’re trying to solve is NP-complete. At that point, you can
stop trying to stop trying to solve it perfectly, and solve it using an
approximation algorithm instead. But it’s hard to tell if a problem
you’re working on is NP-complete. Usually there’s a very small
difference between a problem that’s easy to solve and an NP-complete
problem. For example, in the previous examples, we looked at shortest
paths. You know how to calculate the shortest way to get from point A to
point B. But if you want to fin the shortest path that connects several
points, that’s the traveling-salesman problem, which is NP-complete. The
short answer: there’s no easy way to tell if the problem you’re working
on is NP-complete. Here are some giveaways:</p>
<ul>
<li>Your algorithm runs quickly with a handful of items but really slows
down with more items</li>
<li>“All combinations of X” usually points to an NP-complete
problem.</li>
<li>Do you have to calculate “every possible version” of X because you
can’t break it down into smaller sub-problems? Might be
NP-complete.</li>
<li>If your problem involves a sequence (such as a sequence of cities,
like traveling salesman), and it’s hard to solve, it might be
NP-complete.</li>
<li>If your problem involves a set (like a set of radio stations) and
it’s hard to solve, it might be NP-complete.</li>
<li>Can you restate your problem as the set-covering problem or the
traveling salesman problem? Then your problem is definitly
NP-complete.</li>
</ul>
<p>NP-complete problems show up everywhere.</p>
<h2 id="dynamic-programming---briefly">Dynamic Programming -
Briefly</h2>
<p>Dynamic programming is useful <em>when you’re trying to optimize
something given a constraint</em>. For example, in the knapsack problem,
you had to maximize the value of the goods you stole, constrained by the
size of the knapsack.</p>
<p>You can use dynamic programming when the problem can be broken into
discrete subproblems, and they don’t depend on each other.</p>
<p>It can be hard to come up with a dynamic programming solution. Some
general tips are:</p>
<ul>
<li>Every dynamic programming solution involves a grid.</li>
<li>The values in the cells are usually what you’re trying to optimize.
For the knapsack problem, the values were the value of the goods.</li>
<li>Each cell is a subproblem, so think about how you can divide your
problem into subproblems. That will help you figure out what the axes
are.</li>
</ul>
<h3 id="example---longest-common-substring">Example - Longest common
substring</h3>
<p>Suppose you run dictionary.com. Someone types in a word, and you give
them the definition.</p>
<p>But if someone misspells a word, you want to be able to guess what
word they meant. Alex is searching for <em>fish</em>, but he
accidentally put in <em>hish</em>. That’s not a word in your dictionary,
but you have a list of words that are similar</p>
<p>Similar to “HISH” - “FISH” - “VISTA”</p>
<p>Alex typed <em>hish</em>. Which word did Alex mean to type:
<em>fish</em> or <em>vista</em>?</p>
<h4 id="making-the-grid">Making the grid</h4>
<p>What does the grid for this problem look like? You need to answer
these question:</p>
<ul>
<li>What are the values of the cells?</li>
<li>How do you divide this problem into sub-problems?</li>
<li>What are the axes of the grid?</li>
</ul>
<p>In dynamic programming, you’re trying to <em>maximize</em> something.
In this case, you’re trying to find the longest substring that two words
have in common. What substring do <em>hish</em> and <em>fish</em> have
in common? How about <em>fish</em> and <em>vista</em>? That’s what you
want to calculate.</p>
<p>Remember, the values for the cells are usually what youre trying to
optimize. In this case, the values will probably be a number: the length
of the longest substring that the two string have in common.</p>
<p>How do you divide this problem into subproblems? You could compare
substrings. Instead of comparing <em>hish</em> and <em>fish</em>, you
could compare <em>his</em> and <em>fis</em> first. Each cell will
contain the length of the longest substring that two substring have in
common. This also gives a clue that the axes will probably be the two
words (i.e., with the rows being [“F”, “I”, “S”, “H”’] and columns being
[“H”, “I”, “S”, “H”]).</p>
<h4 id="filling-in-the-grid">Filling in the grid</h4>
<p>Here’s the formula for filling in each cell:</p>
<ol type="1">
<li>If the letters in the row/column pair don’t match, the value is
zero.</li>
<li>If they do match, this value is value of the top-left neighbor +
1</li>
</ol>
<p>Here’s how the formula looks in pseudocode:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> word_a[i] <span class="op">==</span> word_b[j]:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  cell[i][j] <span class="op">=</span> cell[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  cell[i][j] <span class="op">=</span> <span class="dv">0</span></span></code></pre></div>
<p>One thing to note: for this problem, the final solution may not be in
the last cell. For the knapsack problem, this last cell always had the
final solution. But for the longest common substring, the solution is
the largest number in the grid - and it may not be the last cell.</p>
<h3 id="uses-of-dynamic-programming">Uses of dynamic programming</h3>
<ul>
<li>Biologists use the longest common subsequence to find similarities
in DNA strands.</li>
<li>Git diff tells you the differences between two file, and it uses
dynamic programming to do so.</li>
<li>Levenshtein distance measures how similar two string are, and it
uses dynamic programming. Levenshtein distance is used for everything
from spell-check to figuring out whether a user is uploading copyrighted
data.</li>
</ul>
