<h1 id="prime-numbers">Prime Numbers</h1>
<p>Every positive integer can be decomposed into a product of primes.
For example:</p>
<p><span
class="math inline">84 = 2<sup>2</sup> * 3<sup>1</sup> * 5<sup>0</sup> * 7<sup>1</sup> * 11<sup>0</sup> * 13<sup>0</sup> * 17<sup>0</sup> * ...</span></p>
<p>Note that many of these primes have an exponent of zero.</p>
<h2 id="divisibility">Divisibility</h2>
<p>The prime number law stated above means that, in order for a number
<span class="math inline"><em>x</em></span> to be divisiable by a number
<span class="math inline"><em>y</em></span> (written <code>x\y</code> or
<code>mod(y, x) = 0</code>), all primes in <span
class="math inline"><em>x</em></span>’s prime factorization must be in
<span class="math inline"><em>y</em></span>’s prime factorization. Or,
more specifically:</p>
<p>Let: <span
class="math inline"><em>x</em> = 2<sup><em>j</em>0</sup> * 3<sup><em>j</em>1</sup> * 5<sup><em>j</em>2</sup> * 7<sup><em>j</em>3</sup> * 11<sup><em>j</em>4</sup> * ...</span></p>
<p>Let: <span
class="math inline"><em>y</em> = 2<sup><em>k</em>0</sup> * 3<sup><em>k</em>1</sup> * 5<sup><em>k</em>2</sup> * 7<sup><em>k</em>3</sup> * 11<sup><em>k</em>4</sup> * ...</span></p>
<p>If <code>x\y</code>, then for all <code>i</code>,
<code>ji &lt;= ki</code></p>
<p>In fact, the greatest common divisor of <code>x</code> and
<code>y</code> will be:</p>
<p><span
class="math inline"><em>g</em><em>c</em><em>d</em>(<em>x</em>, <em>y</em>) = 2<sup><em>m</em><em>i</em><em>n</em>(<em>j</em>0, <em>k</em>0)</sup> * 3<sup><em>m</em><em>i</em><em>n</em>(<em>j</em>1, <em>k</em>1)</sup> * 5<sup><em>m</em><em>i</em><em>n</em>(<em>j</em>2, <em>k</em>2)</sup> * ...</span></p>
<p>The least common multiple of <code>x</code> and <code>y</code> will
be:</p>
<p><span
class="math inline"><em>l</em><em>c</em><em>m</em>(<em>x</em>, <em>y</em>) = 2<sup><em>m</em><em>a</em><em>x</em>(<em>j</em>0, <em>k</em>0)</sup> * 3<sup><em>m</em><em>a</em><em>x</em>(<em>j</em>1, <em>k</em>1)</sup> * 5<sup><em>m</em><em>a</em><em>x</em>(<em>j</em>2, <em>k</em>2)</sup> * ...</span></p>
<blockquote>
<p>As an exercise, what do you think <span
class="math inline"><em>g</em><em>c</em><em>d</em> * <em>l</em><em>c</em><em>m</em></span>
is?</p>
<p><span
class="math inline"><em>g</em><em>c</em><em>d</em> * <em>l</em><em>c</em><em>m</em> = 2<sup><em>m</em><em>i</em><em>n</em>(<em>j</em>0, <em>k</em>0)</sup> * 2<sup><em>m</em><em>a</em><em>x</em>(<em>j</em>0, <em>k</em>0)</sup> * 3<sup><em>m</em><em>i</em><em>n</em>(<em>j</em>1, <em>k</em>1)</sup> * 3<sup><em>m</em><em>a</em><em>x</em>(<em>j</em>1, <em>k</em>1)</sup> * ...</span></p>
<p><span
class="math inline"><em>g</em><em>c</em><em>d</em> * <em>l</em><em>c</em><em>m</em> = 2<sup><em>m</em><em>i</em><em>n</em>(<em>j</em>0, <em>k</em>0) + <em>m</em><em>a</em><em>x</em>(<em>j</em>0, <em>k</em>0)</sup> * 3<sup><em>m</em><em>i</em><em>n</em>(<em>j</em>1, <em>k</em>1) + <em>m</em><em>a</em><em>x</em>(<em>j</em>1, <em>k</em>1)</sup> * ...</span></p>
<p><span
class="math inline"><em>g</em><em>c</em><em>d</em> * <em>l</em><em>c</em><em>m</em> = 2<sup><em>j</em>0 + <em>k</em>0</sup> * 3<sup><em>j</em>1 + <em>k</em>1</sup> * ...</span></p>
<p><span
class="math inline"><em>g</em><em>c</em><em>d</em> * <em>l</em><em>c</em><em>m</em> = 2<sup><em>j</em>0</sup> * 2<sup><em>k</em>0</sup> * 3<sup><em>j</em>1</sup> * 3<sup><em>k</em>1</sup> * ...</span></p>
<p><span
class="math inline"><em>g</em><em>c</em><em>d</em> * <em>l</em><em>c</em><em>m</em> = <em>x</em><em>y</em></span></p>
</blockquote>
<h2 id="checking-for-primailty">Checking for Primailty</h2>
<p>The naive way to check for primality is to simply iterate from 2
through <span class="math inline"><em>n</em> − 1</span>, checking for
diviibility on each iteration.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime_naive(n):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">%</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit prime_naive(<span class="dv">104729</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(prime_naive(<span class="dv">104729</span>))</span></code></pre></div>
<pre><code>19.2 ms ± 4.35 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
True</code></pre>
<p>A small but important improvement is to iterate only up through the
square root of n.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime_slightly_better(n):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, math.floor(math.sqrt(n))):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">%</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit prime_naive(<span class="dv">104729</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(prime_naive(<span class="dv">104729</span>))</span></code></pre></div>
<pre><code>15.4 ms ± 5.13 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
True</code></pre>
<p>The <span class="math inline"><em>n</em><sup>1/2</sup></span> is
sufficient because, for every number <span
class="math inline"><em>a</em></span> which divides <span
class="math inline"><em>n</em></span> evenly, there is a complement
<span class="math inline"><em>b</em></span>, where <span
class="math inline"><em>a</em> * <em>b</em> = <em>n</em></span>. If
<span
class="math inline"><em>a</em> &gt; <em>n</em><sup>1/2</sup></span>,
then <span
class="math inline"><em>b</em> &lt; <em>n</em><sup>1/2</sup></span>. We
therfore don’t need <span class="math inline"><em>a</em></span> to check
<span class="math inline"><em>n</em></span>’s primailty, since we would
have already checked with <span
class="math inline"><em>b</em></span>.</p>
<p>Of course, in reality, all we really need to do is to check if <span
class="math inline"><em>n</em></span> is divisible by a prime
number.</p>
<h3
id="generating-a-list-of-primes-the-sieve-of-eratosthenes">Generating a
List of Primes: The Sieve of Eratosthenes</h3>
<p>The Sieve of Eratosthenes is a highly efficient way to generate a
list of primes. It works by recognizing that all non-prime numbers are
divisible by a prime number.</p>
<p>We start with a list of all the numbers up through some value
<code>max</code>. First, we cross off all numbers divisible by 2. Then,
we look for the next prime (the next non-crossed off number) and cross
off all numbers divisible by it. By crossing off all numbers divisible
by 2, 3, 5, 7, 11, and so on, we wind up with a list of prime numbers
from 2 through <code>max</code>.</p>
<p>The code below implements the Sieve of Eratosthenes:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sieve_of_eratosthenes(<span class="bu">max</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    flags <span class="op">=</span> [<span class="va">True</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">max</span><span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    flags[<span class="dv">0</span>] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    flags[<span class="dv">1</span>] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    prime <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> prime <span class="op">&lt;=</span> math.sqrt(<span class="bu">max</span>):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Cross off remaining multiples of prime</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        cross_off(flags, prime)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find next value which is true</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        prime <span class="op">=</span> get_next_prime(flags, prime)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flags</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross_off(flags, prime):</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cross off remaining multiples of prime.</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We canstart with (prime*prime), because if we have a k*prime,</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># where k &lt; prime, this value would have already been crossed</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># off in a prior iteration.</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> prime<span class="op">*</span>prime</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(flags):</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        flags[i] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> prime</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_next_prime(flags, prime):</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    next_prime <span class="op">=</span> prime <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> next_prime <span class="op">&lt;</span> <span class="bu">len</span>(flags) <span class="kw">and</span> <span class="kw">not</span> flags[next_prime]:</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        next_prime <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> next_prime</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>test_prime <span class="op">=</span> <span class="dv">11</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;List of primes up to </span><span class="sc">{</span>test_prime<span class="sc">}</span><span class="ss">:&quot;</span>)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sieve_of_eratosthenes(test_prime))</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>test_large_prime <span class="op">=</span> <span class="dv">104729</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit sieve_of_eratosthenes(test_large_prime)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sieve_of_eratosthenes(test_large_prime)[test_large_prime])</span></code></pre></div>
<pre><code>List of primes up to 11:
[False, False, True, True, False, True, False, True, False, False, False, True]

86.7 ms ± 38.2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
True</code></pre>
<p>Of course, there are a number of optimizations that can be made to
this. One simple one is to only use off numbers in the array, which
would allow us to reduce our space usage by half.</p>
